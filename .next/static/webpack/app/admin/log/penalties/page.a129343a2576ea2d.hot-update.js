"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/log/penalties/page",{

/***/ "(app-pages-browser)/./contexts/AuthContext.tsx":
/*!**********************************!*\
  !*** ./contexts/AuthContext.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Restore session from Supabase on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const restoreSession = async ()=>{\n            try {\n                // Import supabase client dynamically\n                const { supabase } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_supabase_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\"));\n                if (!supabase) {\n                    // Fallback to localStorage if Supabase not configured\n                    const savedUser = localStorage.getItem(\"currentUser\");\n                    if (savedUser) {\n                        try {\n                            const parsedUser = JSON.parse(savedUser);\n                            setUser(parsedUser);\n                        } catch (error) {\n                            console.error(\"Error parsing saved user:\", error);\n                        }\n                    }\n                    setIsLoading(false);\n                    return;\n                }\n                // Check for existing Supabase session\n                const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n                if (sessionError) {\n                    console.error(\"Error getting session:\", sessionError);\n                    // Fallback to localStorage\n                    const savedUser = localStorage.getItem(\"currentUser\");\n                    if (savedUser) {\n                        try {\n                            const parsedUser = JSON.parse(savedUser);\n                            setUser(parsedUser);\n                        } catch (error) {\n                            console.error(\"Error parsing saved user:\", error);\n                        }\n                    }\n                    setIsLoading(false);\n                    return;\n                }\n                if (session === null || session === void 0 ? void 0 : session.user) {\n                    // Session exists, fetch user data from users table\n                    const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"auth_user_id\", session.user.id).single();\n                    if (userError || !userData) {\n                        // User doesn't exist in users table, but session is valid\n                        // This shouldn't happen, but handle gracefully\n                        console.warn(\"Session exists but user not found in users table\");\n                        // Clear invalid session\n                        await supabase.auth.signOut();\n                        localStorage.removeItem(\"currentUser\");\n                        setUser(null);\n                        setIsLoading(false);\n                        return;\n                    }\n                    // Map database role to UserRole type\n                    const roleMap = {\n                        \"organizational\": \"organizational\",\n                        \"coach\": \"coach\",\n                        \"player\": \"player\",\n                        \"parent\": \"parent\"\n                    };\n                    const restoredUser = {\n                        id: userData.id,\n                        email: userData.email,\n                        name: userData.name || userData.email.split(\"@\")[0],\n                        role: roleMap[userData.role] || \"organizational\",\n                        organizationId: userData.organization_id || null,\n                        authUserId: session.user.id\n                    };\n                    setUser(restoredUser);\n                    // Also save to localStorage as backup\n                    localStorage.setItem(\"currentUser\", JSON.stringify(restoredUser));\n                } else {\n                    // No session, check localStorage as fallback\n                    const savedUser = localStorage.getItem(\"currentUser\");\n                    if (savedUser) {\n                        try {\n                            const parsedUser = JSON.parse(savedUser);\n                            setUser(parsedUser);\n                        } catch (error) {\n                            console.error(\"Error parsing saved user:\", error);\n                            localStorage.removeItem(\"currentUser\");\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error restoring session:\", error);\n                // Fallback to localStorage\n                const savedUser = localStorage.getItem(\"currentUser\");\n                if (savedUser) {\n                    try {\n                        const parsedUser = JSON.parse(savedUser);\n                        setUser(parsedUser);\n                    } catch (parseError) {\n                        console.error(\"Error parsing saved user:\", parseError);\n                        localStorage.removeItem(\"currentUser\");\n                    }\n                }\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        restoreSession();\n        // Listen for auth state changes (e.g., token refresh, logout from another tab)\n        let subscription = null;\n        let isMounted = true;\n        const setupAuthListener = async ()=>{\n            try {\n                const { supabase } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_supabase_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\"));\n                if (supabase && isMounted) {\n                    const { data: { subscription: authSubscription } } = supabase.auth.onAuthStateChange(async (event, session)=>{\n                        if (!isMounted) return;\n                        if (event === \"SIGNED_OUT\" || !session) {\n                            setUser(null);\n                            localStorage.removeItem(\"currentUser\");\n                        } else if (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\") {\n                            if (session === null || session === void 0 ? void 0 : session.user) {\n                                // Fetch user data from users table\n                                const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"auth_user_id\", session.user.id).single();\n                                if (!userError && userData && isMounted) {\n                                    const roleMap = {\n                                        \"organizational\": \"organizational\",\n                                        \"coach\": \"coach\",\n                                        \"player\": \"player\",\n                                        \"parent\": \"parent\"\n                                    };\n                                    const updatedUser = {\n                                        id: userData.id,\n                                        email: userData.email,\n                                        name: userData.name || userData.email.split(\"@\")[0],\n                                        role: roleMap[userData.role] || \"organizational\",\n                                        organizationId: userData.organization_id || null,\n                                        authUserId: session.user.id\n                                    };\n                                    setUser(updatedUser);\n                                    localStorage.setItem(\"currentUser\", JSON.stringify(updatedUser));\n                                }\n                            }\n                        }\n                    });\n                    if (isMounted) {\n                        subscription = authSubscription;\n                    } else {\n                        authSubscription.unsubscribe();\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error setting up auth listener:\", error);\n            }\n        };\n        setupAuthListener();\n        return ()=>{\n            isMounted = false;\n            if (subscription) {\n                subscription.unsubscribe();\n            }\n        };\n    }, []);\n    // Save user to localStorage when it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (user) {\n            localStorage.setItem(\"currentUser\", JSON.stringify(user));\n        } else {\n            localStorage.removeItem(\"currentUser\");\n        }\n    }, [\n        user\n    ]);\n    const login = async (email, password)=>{\n        try {\n            // Import supabase client dynamically\n            const { supabase } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_supabase_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\"));\n            if (!supabase) {\n                throw new Error(\"Supabase not configured\");\n            }\n            // Authenticate with Supabase Auth\n            const { data: authData, error: authError } = await supabase.auth.signInWithPassword({\n                email,\n                password\n            });\n            if (authError) {\n                throw new Error(authError.message || \"Invalid email or password\");\n            }\n            if (!authData.user) {\n                throw new Error(\"Authentication failed\");\n            }\n            // Fetch user data from users table\n            const { data: userData, error: userError } = await supabase.from(\"users\").select(\"*\").eq(\"auth_user_id\", authData.user.id).single();\n            if (userError || !userData) {\n                var _authData_user_user_metadata, _authData_user_email;\n                // If user doesn't exist in users table, create a basic user object\n                // This shouldn't happen in production, but handle gracefully\n                setUser({\n                    id: authData.user.id,\n                    email: authData.user.email || email,\n                    name: ((_authData_user_user_metadata = authData.user.user_metadata) === null || _authData_user_user_metadata === void 0 ? void 0 : _authData_user_user_metadata.name) || ((_authData_user_email = authData.user.email) === null || _authData_user_email === void 0 ? void 0 : _authData_user_email.split(\"@\")[0]) || \"User\",\n                    role: \"organizational\",\n                    organizationId: null,\n                    authUserId: authData.user.id\n                });\n                return;\n            }\n            // Map database role to UserRole type\n            const roleMap = {\n                \"organizational\": \"organizational\",\n                \"coach\": \"coach\",\n                \"player\": \"player\",\n                \"parent\": \"parent\"\n            };\n            setUser({\n                id: userData.id,\n                email: userData.email,\n                name: userData.name || userData.email.split(\"@\")[0],\n                role: roleMap[userData.role] || \"organizational\",\n                organizationId: userData.organization_id || null,\n                authUserId: authData.user.id\n            });\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    };\n    const logout = async ()=>{\n        try {\n            // Import supabase client dynamically\n            const { supabase } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_supabase_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\"));\n            if (supabase) {\n                // Sign out from Supabase (this will clear the session)\n                await supabase.auth.signOut();\n            }\n        } catch (error) {\n            console.error(\"Error during logout:\", error);\n        } finally{\n            // Always clear local state regardless of Supabase logout result\n            setUser(null);\n            localStorage.removeItem(\"currentUser\");\n            // Clear all selected log items when logging out\n            if (true) {\n                // Clear from localStorage if stored there\n                localStorage.removeItem(\"selectedLogItems\");\n                // Also clear from sessionStorage\n                sessionStorage.removeItem(\"selectedLogItems\");\n                // Clear from gameState as well\n                const gameState = localStorage.getItem(\"gameState\");\n                if (gameState) {\n                    try {\n                        const state = JSON.parse(gameState);\n                        state.selectedLogItems = [];\n                        localStorage.setItem(\"gameState\", JSON.stringify(state));\n                    } catch (e) {\n                        console.error(\"Error clearing selectedLogItems from gameState:\", e);\n                    }\n                }\n            }\n        }\n    };\n    const isAdmin = (user === null || user === void 0 ? void 0 : user.role) === \"organizational\";\n    const isAuthenticated = user !== null;\n    // Super admin check: Only specific email addresses can access admin testing features\n    // Add your super admin email here - this should be kept secure\n    const SUPER_ADMIN_EMAILS = [\n        \"icepulsereact@gmail.com\" || 0,\n        \"williamdoss@icepulse.com\"\n    ].filter(Boolean) // Remove any undefined/null values\n    ;\n    const isSuperAdmin = (user === null || user === void 0 ? void 0 : user.email) ? SUPER_ADMIN_EMAILS.includes(user.email.toLowerCase()) : false;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isAuthenticated,\n            isAdmin,\n            isSuperAdmin,\n            isLoading,\n            login,\n            logout,\n            setUser\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/williamdoss/Ice-Pulse-Conneect/contexts/AuthContext.tsx\",\n        lineNumber: 338,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"l8KTfcQ0b0tPgqlKoCac6dKortU=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n}\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL0F1dGhDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXdGO0FBd0J4RixNQUFNSyw0QkFBY0osb0RBQWFBLENBQThCSztBQUV4RCxTQUFTQyxhQUFhLEtBQXFDO1FBQXJDLEVBQUVDLFFBQVEsRUFBMkIsR0FBckM7O0lBQzNCLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHUCwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MseUNBQXlDO0lBQ3pDQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGlCQUFpQjtZQUNyQixJQUFJO2dCQUNGLHFDQUFxQztnQkFDckMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxNQUFNLDhMQUFPO2dCQUVsQyxJQUFJLENBQUNBLFVBQVU7b0JBQ2Isc0RBQXNEO29CQUN0RCxNQUFNQyxZQUFZQyxhQUFhQyxPQUFPLENBQUM7b0JBQ3ZDLElBQUlGLFdBQVc7d0JBQ2IsSUFBSTs0QkFDRixNQUFNRyxhQUFhQyxLQUFLQyxLQUFLLENBQUNMOzRCQUM5QkwsUUFBUVE7d0JBQ1YsRUFBRSxPQUFPRyxPQUFPOzRCQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTt3QkFDN0M7b0JBQ0Y7b0JBQ0FULGFBQWE7b0JBQ2I7Z0JBQ0Y7Z0JBRUEsc0NBQXNDO2dCQUN0QyxNQUFNLEVBQUVXLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEVBQUVILE9BQU9JLFlBQVksRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQ0MsVUFBVTtnQkFFakYsSUFBSUYsY0FBYztvQkFDaEJILFFBQVFELEtBQUssQ0FBQywwQkFBMEJJO29CQUN4QywyQkFBMkI7b0JBQzNCLE1BQU1WLFlBQVlDLGFBQWFDLE9BQU8sQ0FBQztvQkFDdkMsSUFBSUYsV0FBVzt3QkFDYixJQUFJOzRCQUNGLE1BQU1HLGFBQWFDLEtBQUtDLEtBQUssQ0FB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K0M7WUFDQVE7WUFDQXhEO1FBQ0Y7a0JBRUNGOzs7Ozs7QUFHUDtHQXBVZ0JEO0tBQUFBO0FBc1VULFNBQVM4RTs7SUFDZCxNQUFNQyxVQUFVcEYsaURBQVVBLENBQUNHO0lBQzNCLElBQUlpRixZQUFZaEYsV0FBVztRQUN6QixNQUFNLElBQUlzRCxNQUFNO0lBQ2xCO0lBQ0EsT0FBTzBCO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHRzL0F1dGhDb250ZXh0LnRzeD82ZDgxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgVXNlclJvbGUgPSAnb3JnYW5pemF0aW9uYWwnIHwgJ2NvYWNoJyB8ICdwbGF5ZXInIHwgJ3BhcmVudCdcblxuaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHJvbGU6IFVzZXJSb2xlXG4gIG9yZ2FuaXphdGlvbklkOiBzdHJpbmcgfCBudWxsXG4gIGF1dGhVc2VySWQ6IHN0cmluZyB8IG51bGxcbn1cblxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XG4gIHVzZXI6IFVzZXIgfCBudWxsXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhblxuICBpc0FkbWluOiBib29sZWFuIC8vIFRydWUgaWYgcm9sZSBpcyAnb3JnYW5pemF0aW9uYWwnXG4gIGlzU3VwZXJBZG1pbjogYm9vbGVhbiAvLyBUcnVlIGlmIHVzZXIgaXMgdGhlIGRlc2lnbmF0ZWQgc3VwZXIgYWRtaW4gKGZvciB0ZXN0aW5nL2FkbWluIGZlYXR1cmVzKVxuICBpc0xvYWRpbmc6IGJvb2xlYW5cbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGxvZ291dDogKCkgPT4gdm9pZFxuICBzZXRVc2VyOiAodXNlcjogVXNlciB8IG51bGwpID0+IHZvaWRcbn1cblxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIC8vIFJlc3RvcmUgc2Vzc2lvbiBmcm9tIFN1cGFiYXNlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmVzdG9yZVNlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbXBvcnQgc3VwYWJhc2UgY2xpZW50IGR5bmFtaWNhbGx5XG4gICAgICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2UnKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFzdXBhYmFzZSkge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsU3RvcmFnZSBpZiBTdXBhYmFzZSBub3QgY29uZmlndXJlZFxuICAgICAgICAgIGNvbnN0IHNhdmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcicpXG4gICAgICAgICAgaWYgKHNhdmVkVXNlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVXNlciA9IEpTT04ucGFyc2Uoc2F2ZWRVc2VyKVxuICAgICAgICAgICAgICBzZXRVc2VyKHBhcnNlZFVzZXIpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNhdmVkIHVzZXI6JywgZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBTdXBhYmFzZSBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpXG4gICAgICAgIFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzZXNzaW9uOicsIHNlc3Npb25FcnJvcilcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICBjb25zdCBzYXZlZFVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY3VycmVudFVzZXInKVxuICAgICAgICAgIGlmIChzYXZlZFVzZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVzZXIgPSBKU09OLnBhcnNlKHNhdmVkVXNlcilcbiAgICAgICAgICAgICAgc2V0VXNlcihwYXJzZWRVc2VyKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzYXZlZCB1c2VyOicsIGVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vzc2lvbj8udXNlcikge1xuICAgICAgICAgIC8vIFNlc3Npb24gZXhpc3RzLCBmZXRjaCB1c2VyIGRhdGEgZnJvbSB1c2VycyB0YWJsZVxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAuZXEoJ2F1dGhfdXNlcl9pZCcsIHNlc3Npb24udXNlci5pZClcbiAgICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlckRhdGEpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgZG9lc24ndCBleGlzdCBpbiB1c2VycyB0YWJsZSwgYnV0IHNlc3Npb24gaXMgdmFsaWRcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGhhbmRsZSBncmFjZWZ1bGx5XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Nlc3Npb24gZXhpc3RzIGJ1dCB1c2VyIG5vdCBmb3VuZCBpbiB1c2VycyB0YWJsZScpXG4gICAgICAgICAgICAvLyBDbGVhciBpbnZhbGlkIHNlc3Npb25cbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY3VycmVudFVzZXInKVxuICAgICAgICAgICAgc2V0VXNlcihudWxsKVxuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFwIGRhdGFiYXNlIHJvbGUgdG8gVXNlclJvbGUgdHlwZVxuICAgICAgICAgIGNvbnN0IHJvbGVNYXA6IFJlY29yZDxzdHJpbmcsIFVzZXJSb2xlPiA9IHtcbiAgICAgICAgICAgICdvcmdhbml6YXRpb25hbCc6ICdvcmdhbml6YXRpb25hbCcsXG4gICAgICAgICAgICAnY29hY2gnOiAnY29hY2gnLFxuICAgICAgICAgICAgJ3BsYXllcic6ICdwbGF5ZXInLFxuICAgICAgICAgICAgJ3BhcmVudCc6ICdwYXJlbnQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdG9yZWRVc2VyOiBVc2VyID0ge1xuICAgICAgICAgICAgaWQ6IHVzZXJEYXRhLmlkLFxuICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICAgICAgbmFtZTogdXNlckRhdGEubmFtZSB8fCB1c2VyRGF0YS5lbWFpbC5zcGxpdCgnQCcpWzBdLFxuICAgICAgICAgICAgcm9sZTogcm9sZU1hcFt1c2VyRGF0YS5yb2xlXSB8fCAnb3JnYW5pemF0aW9uYWwnLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHVzZXJEYXRhLm9yZ2FuaXphdGlvbl9pZCB8fCBudWxsLFxuICAgICAgICAgICAgYXV0aFVzZXJJZDogc2Vzc2lvbi51c2VyLmlkLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFVzZXIocmVzdG9yZWRVc2VyKVxuICAgICAgICAgIC8vIEFsc28gc2F2ZSB0byBsb2NhbFN0b3JhZ2UgYXMgYmFja3VwXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VyJywgSlNPTi5zdHJpbmdpZnkocmVzdG9yZWRVc2VyKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBzZXNzaW9uLCBjaGVjayBsb2NhbFN0b3JhZ2UgYXMgZmFsbGJhY2tcbiAgICAgICAgICBjb25zdCBzYXZlZFVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY3VycmVudFVzZXInKVxuICAgICAgICAgIGlmIChzYXZlZFVzZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVzZXIgPSBKU09OLnBhcnNlKHNhdmVkVXNlcilcbiAgICAgICAgICAgICAgc2V0VXNlcihwYXJzZWRVc2VyKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzYXZlZCB1c2VyOicsIGVycm9yKVxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY3VycmVudFVzZXInKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzdG9yaW5nIHNlc3Npb246JywgZXJyb3IpXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICBjb25zdCBzYXZlZFVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY3VycmVudFVzZXInKVxuICAgICAgICBpZiAoc2F2ZWRVc2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVzZXIgPSBKU09OLnBhcnNlKHNhdmVkVXNlcilcbiAgICAgICAgICAgIHNldFVzZXIocGFyc2VkVXNlcilcbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNhdmVkIHVzZXI6JywgcGFyc2VFcnJvcilcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZVNlc3Npb24oKVxuXG4gICAgLy8gTGlzdGVuIGZvciBhdXRoIHN0YXRlIGNoYW5nZXMgKGUuZy4sIHRva2VuIHJlZnJlc2gsIGxvZ291dCBmcm9tIGFub3RoZXIgdGFiKVxuICAgIGxldCBzdWJzY3JpcHRpb246IHsgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQgfSB8IG51bGwgPSBudWxsXG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWVcbiAgICBcbiAgICBjb25zdCBzZXR1cEF1dGhMaXN0ZW5lciA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2UnKVxuICAgICAgICBpZiAoc3VwYWJhc2UgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHN1YnNjcmlwdGlvbjogYXV0aFN1YnNjcmlwdGlvbiB9IH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKGFzeW5jIChldmVudCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHJldHVyblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJyB8fCAhc2Vzc2lvbikge1xuICAgICAgICAgICAgICBzZXRVc2VyKG51bGwpXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnU0lHTkVEX0lOJyB8fCBldmVudCA9PT0gJ1RPS0VOX1JFRlJFU0hFRCcpIHtcbiAgICAgICAgICAgICAgaWYgKHNlc3Npb24/LnVzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCB1c2VyIGRhdGEgZnJvbSB1c2VycyB0YWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAuZXEoJ2F1dGhfdXNlcl9pZCcsIHNlc3Npb24udXNlci5pZClcbiAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IgJiYgdXNlckRhdGEgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByb2xlTWFwOiBSZWNvcmQ8c3RyaW5nLCBVc2VyUm9sZT4gPSB7XG4gICAgICAgICAgICAgICAgICAgICdvcmdhbml6YXRpb25hbCc6ICdvcmdhbml6YXRpb25hbCcsXG4gICAgICAgICAgICAgICAgICAgICdjb2FjaCc6ICdjb2FjaCcsXG4gICAgICAgICAgICAgICAgICAgICdwbGF5ZXInOiAncGxheWVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BhcmVudCc6ICdwYXJlbnQnXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRVc2VyOiBVc2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogdXNlckRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdXNlckRhdGEubmFtZSB8fCB1c2VyRGF0YS5lbWFpbC5zcGxpdCgnQCcpWzBdLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiByb2xlTWFwW3VzZXJEYXRhLnJvbGVdIHx8ICdvcmdhbml6YXRpb25hbCcsXG4gICAgICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbklkOiB1c2VyRGF0YS5vcmdhbml6YXRpb25faWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aFVzZXJJZDogc2Vzc2lvbi51c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzZXRVc2VyKHVwZGF0ZWRVc2VyKVxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VyJywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFVzZXIpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gYXV0aFN1YnNjcmlwdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdXRoU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgdXAgYXV0aCBsaXN0ZW5lcjonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cEF1dGhMaXN0ZW5lcigpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2VcbiAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFNhdmUgdXNlciB0byBsb2NhbFN0b3JhZ2Ugd2hlbiBpdCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VXNlcicsIEpTT04uc3RyaW5naWZ5KHVzZXIpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY3VycmVudFVzZXInKVxuICAgIH1cbiAgfSwgW3VzZXJdKVxuXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW1wb3J0IHN1cGFiYXNlIGNsaWVudCBkeW5hbWljYWxseVxuICAgICAgY29uc3QgeyBzdXBhYmFzZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9zdXBhYmFzZScpXG4gICAgICBcbiAgICAgIGlmICghc3VwYWJhc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBhYmFzZSBub3QgY29uZmlndXJlZCcpXG4gICAgICB9XG5cbiAgICAgIC8vIEF1dGhlbnRpY2F0ZSB3aXRoIFN1cGFiYXNlIEF1dGhcbiAgICAgIGNvbnN0IHsgZGF0YTogYXV0aERhdGEsIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgfSlcblxuICAgICAgaWYgKGF1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXV0aEVycm9yLm1lc3NhZ2UgfHwgJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF1dGhEYXRhLnVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB1c2VyIGRhdGEgZnJvbSB1c2VycyB0YWJsZVxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnYXV0aF91c2VyX2lkJywgYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1c2VyRXJyb3IgfHwgIXVzZXJEYXRhKSB7XG4gICAgICAgIC8vIElmIHVzZXIgZG9lc24ndCBleGlzdCBpbiB1c2VycyB0YWJsZSwgY3JlYXRlIGEgYmFzaWMgdXNlciBvYmplY3RcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGluIHByb2R1Y3Rpb24sIGJ1dCBoYW5kbGUgZ3JhY2VmdWxseVxuICAgICAgICBzZXRVc2VyKHtcbiAgICAgICAgICBpZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICBlbWFpbDogYXV0aERhdGEudXNlci5lbWFpbCB8fCBlbWFpbCxcbiAgICAgICAgICBuYW1lOiBhdXRoRGF0YS51c2VyLnVzZXJfbWV0YWRhdGE/Lm5hbWUgfHwgYXV0aERhdGEudXNlci5lbWFpbD8uc3BsaXQoJ0AnKVswXSB8fCAnVXNlcicsXG4gICAgICAgICAgcm9sZTogJ29yZ2FuaXphdGlvbmFsJywgLy8gRGVmYXVsdCByb2xlXG4gICAgICAgICAgb3JnYW5pemF0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgYXV0aFVzZXJJZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCBkYXRhYmFzZSByb2xlIHRvIFVzZXJSb2xlIHR5cGVcbiAgICAgIGNvbnN0IHJvbGVNYXA6IFJlY29yZDxzdHJpbmcsIFVzZXJSb2xlPiA9IHtcbiAgICAgICAgJ29yZ2FuaXphdGlvbmFsJzogJ29yZ2FuaXphdGlvbmFsJyxcbiAgICAgICAgJ2NvYWNoJzogJ2NvYWNoJyxcbiAgICAgICAgJ3BsYXllcic6ICdwbGF5ZXInLFxuICAgICAgICAncGFyZW50JzogJ3BhcmVudCdcbiAgICAgIH1cblxuICAgICAgc2V0VXNlcih7XG4gICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBuYW1lOiB1c2VyRGF0YS5uYW1lIHx8IHVzZXJEYXRhLmVtYWlsLnNwbGl0KCdAJylbMF0sXG4gICAgICAgIHJvbGU6IHJvbGVNYXBbdXNlckRhdGEucm9sZV0gfHwgJ29yZ2FuaXphdGlvbmFsJyxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHVzZXJEYXRhLm9yZ2FuaXphdGlvbl9pZCB8fCBudWxsLFxuICAgICAgICBhdXRoVXNlcklkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbXBvcnQgc3VwYWJhc2UgY2xpZW50IGR5bmFtaWNhbGx5XG4gICAgICBjb25zdCB7IHN1cGFiYXNlIH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL3N1cGFiYXNlJylcbiAgICAgIFxuICAgICAgaWYgKHN1cGFiYXNlKSB7XG4gICAgICAgIC8vIFNpZ24gb3V0IGZyb20gU3VwYWJhc2UgKHRoaXMgd2lsbCBjbGVhciB0aGUgc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGxvZ291dDonLCBlcnJvcilcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQWx3YXlzIGNsZWFyIGxvY2FsIHN0YXRlIHJlZ2FyZGxlc3Mgb2YgU3VwYWJhc2UgbG9nb3V0IHJlc3VsdFxuICAgICAgc2V0VXNlcihudWxsKVxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2N1cnJlbnRVc2VyJylcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgYWxsIHNlbGVjdGVkIGxvZyBpdGVtcyB3aGVuIGxvZ2dpbmcgb3V0XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQ2xlYXIgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgc3RvcmVkIHRoZXJlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzZWxlY3RlZExvZ0l0ZW1zJylcbiAgICAgICAgLy8gQWxzbyBjbGVhciBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3NlbGVjdGVkTG9nSXRlbXMnKVxuICAgICAgICAvLyBDbGVhciBmcm9tIGdhbWVTdGF0ZSBhcyB3ZWxsXG4gICAgICAgIGNvbnN0IGdhbWVTdGF0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdnYW1lU3RhdGUnKVxuICAgICAgICBpZiAoZ2FtZVN0YXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShnYW1lU3RhdGUpXG4gICAgICAgICAgICBzdGF0ZS5zZWxlY3RlZExvZ0l0ZW1zID0gW11cbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnYW1lU3RhdGUnLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgc2VsZWN0ZWRMb2dJdGVtcyBmcm9tIGdhbWVTdGF0ZTonLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzQWRtaW4gPSB1c2VyPy5yb2xlID09PSAnb3JnYW5pemF0aW9uYWwnXG4gIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9IHVzZXIgIT09IG51bGxcbiAgXG4gIC8vIFN1cGVyIGFkbWluIGNoZWNrOiBPbmx5IHNwZWNpZmljIGVtYWlsIGFkZHJlc3NlcyBjYW4gYWNjZXNzIGFkbWluIHRlc3RpbmcgZmVhdHVyZXNcbiAgLy8gQWRkIHlvdXIgc3VwZXIgYWRtaW4gZW1haWwgaGVyZSAtIHRoaXMgc2hvdWxkIGJlIGtlcHQgc2VjdXJlXG4gIGNvbnN0IFNVUEVSX0FETUlOX0VNQUlMUyA9IFtcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBFUl9BRE1JTl9FTUFJTCB8fCAnYWRtaW5AaWNlcHVsc2UuY29tJyxcbiAgICAnd2lsbGlhbWRvc3NAaWNlcHVsc2UuY29tJywgLy8gQWRkIHlvdXIgZW1haWwgaGVyZVxuICBdLmZpbHRlcihCb29sZWFuKSAvLyBSZW1vdmUgYW55IHVuZGVmaW5lZC9udWxsIHZhbHVlc1xuICBjb25zdCBpc1N1cGVyQWRtaW4gPSB1c2VyPy5lbWFpbCA/IFNVUEVSX0FETUlOX0VNQUlMUy5pbmNsdWRlcyh1c2VyLmVtYWlsLnRvTG93ZXJDYXNlKCkpIDogZmFsc2VcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgdXNlcixcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkLFxuICAgICAgICBpc0FkbWluLFxuICAgICAgICBpc1N1cGVyQWRtaW4sXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgbG9naW4sXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgc2V0VXNlcixcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dGgoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwicmVzdG9yZVNlc3Npb24iLCJzdXBhYmFzZSIsInNhdmVkVXNlciIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRVc2VyIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwiZGF0YSIsInNlc3Npb24iLCJzZXNzaW9uRXJyb3IiLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsInVzZXJEYXRhIiwidXNlckVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJzaW5nbGUiLCJ3YXJuIiwic2lnbk91dCIsInJlbW92ZUl0ZW0iLCJyb2xlTWFwIiwicmVzdG9yZWRVc2VyIiwiZW1haWwiLCJuYW1lIiwic3BsaXQiLCJyb2xlIiwib3JnYW5pemF0aW9uSWQiLCJvcmdhbml6YXRpb25faWQiLCJhdXRoVXNlcklkIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInBhcnNlRXJyb3IiLCJzdWJzY3JpcHRpb24iLCJpc01vdW50ZWQiLCJzZXR1cEF1dGhMaXN0ZW5lciIsImF1dGhTdWJzY3JpcHRpb24iLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50IiwidXBkYXRlZFVzZXIiLCJ1bnN1YnNjcmliZSIsImxvZ2luIiwicGFzc3dvcmQiLCJFcnJvciIsImF1dGhEYXRhIiwiYXV0aEVycm9yIiwic2lnbkluV2l0aFBhc3N3b3JkIiwibWVzc2FnZSIsInVzZXJfbWV0YWRhdGEiLCJsb2dvdXQiLCJzZXNzaW9uU3RvcmFnZSIsImdhbWVTdGF0ZSIsInN0YXRlIiwic2VsZWN0ZWRMb2dJdGVtcyIsImUiLCJpc0FkbWluIiwiaXNBdXRoZW50aWNhdGVkIiwiU1VQRVJfQURNSU5fRU1BSUxTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEVSX0FETUlOX0VNQUlMIiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzU3VwZXJBZG1pbiIsImluY2x1ZGVzIiwidG9Mb3dlckNhc2UiLCJQcm92aWRlciIsInZhbHVlIiwidXNlQXV0aCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/AuthContext.tsx\n"));

/***/ })

});